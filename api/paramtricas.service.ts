/**
 * API SST
 * Api para aplicaciones del proyecto SST
 *
 * OpenAPI spec version: 1.0.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Ciudad } from '../model/ciudad';
import { Departamento } from '../model/departamento';
import { Diagnosticoincapacidad } from '../model/diagnosticoincapacidad';
import { ErrorModel } from '../model/errorModel';
import { Evidenciacumplimiento } from '../model/evidenciacumplimiento';
import { Frecuencia } from '../model/frecuencia';
import { Fuenteinformacion } from '../model/fuenteinformacion';
import { Idoneidadinstructor } from '../model/idoneidadinstructor';
import { Partecuerpo } from '../model/partecuerpo';
import { Preguntasencuesta } from '../model/preguntasencuesta';
import { Sistemaevaluacion } from '../model/sistemaevaluacion';
import { Tipoaccidente } from '../model/tipoaccidente';
import { Tipoactividad } from '../model/tipoactividad';
import { Tipocontrato } from '../model/tipocontrato';
import { Tipoevento } from '../model/tipoevento';
import { Tipoindicador } from '../model/tipoindicador';
import { Tipolesion } from '../model/tipolesion';
import { Tiporecurso } from '../model/tiporecurso';
import { Tiporesponsabilidad } from '../model/tiporesponsabilidad';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ParamtricasService {

    protected basePath = 'https://localhost/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Trae todos las ciudades
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ciudadGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Ciudad>>;
    public ciudadGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Ciudad>>>;
    public ciudadGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Ciudad>>>;
    public ciudadGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Ciudad>>(`${this.basePath}/ciudad`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae una ciudad por id
     * 
     * @param idCiudad id de la ciudad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ciudadIdCiudadGet(idCiudad: number, observe?: 'body', reportProgress?: boolean): Observable<Ciudad>;
    public ciudadIdCiudadGet(idCiudad: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Ciudad>>;
    public ciudadIdCiudadGet(idCiudad: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ciudad>>;
    public ciudadIdCiudadGet(idCiudad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idCiudad === null || idCiudad === undefined) {
            throw new Error('Required parameter idCiudad was null or undefined when calling ciudadIdCiudadGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Ciudad>(`${this.basePath}/ciudad/${encodeURIComponent(String(idCiudad))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar una ciudad por id
     * 
     * @param idCiudad id de la ciudad
     * @param ciudad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ciudadIdCiudadPut(idCiudad: number, ciudad?: any, observe?: 'body', reportProgress?: boolean): Observable<Ciudad>;
    public ciudadIdCiudadPut(idCiudad: number, ciudad?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Ciudad>>;
    public ciudadIdCiudadPut(idCiudad: number, ciudad?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ciudad>>;
    public ciudadIdCiudadPut(idCiudad: number, ciudad?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idCiudad === null || idCiudad === undefined) {
            throw new Error('Required parameter idCiudad was null or undefined when calling ciudadIdCiudadPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Ciudad>(`${this.basePath}/ciudad/${encodeURIComponent(String(idCiudad))}`,
            ciudad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de ciudad
     * 
     * @param ciudad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ciudadPost(ciudad: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public ciudadPost(ciudad: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public ciudadPost(ciudad: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public ciudadPost(ciudad: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ciudad === null || ciudad === undefined) {
            throw new Error('Required parameter ciudad was null or undefined when calling ciudadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/ciudad`,
            ciudad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los departamentos de las empresas
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public departamentoGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Departamento>>;
    public departamentoGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Departamento>>>;
    public departamentoGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Departamento>>>;
    public departamentoGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Departamento>>(`${this.basePath}/departamento`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un departamento por id
     * 
     * @param idDepartamento id del departamento
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public departamentoIdDepartamentoGet(idDepartamento: number, observe?: 'body', reportProgress?: boolean): Observable<Departamento>;
    public departamentoIdDepartamentoGet(idDepartamento: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Departamento>>;
    public departamentoIdDepartamentoGet(idDepartamento: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Departamento>>;
    public departamentoIdDepartamentoGet(idDepartamento: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idDepartamento === null || idDepartamento === undefined) {
            throw new Error('Required parameter idDepartamento was null or undefined when calling departamentoIdDepartamentoGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Departamento>(`${this.basePath}/departamento/${encodeURIComponent(String(idDepartamento))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un departamento por id
     * 
     * @param idDepartamento id del departamento
     * @param departamento 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public departamentoIdDepartamentoPut(idDepartamento: number, departamento?: any, observe?: 'body', reportProgress?: boolean): Observable<Departamento>;
    public departamentoIdDepartamentoPut(idDepartamento: number, departamento?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Departamento>>;
    public departamentoIdDepartamentoPut(idDepartamento: number, departamento?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Departamento>>;
    public departamentoIdDepartamentoPut(idDepartamento: number, departamento?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idDepartamento === null || idDepartamento === undefined) {
            throw new Error('Required parameter idDepartamento was null or undefined when calling departamentoIdDepartamentoPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Departamento>(`${this.basePath}/departamento/${encodeURIComponent(String(idDepartamento))}`,
            departamento,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de departamento
     * 
     * @param departamento 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public departamentoPost(departamento: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public departamentoPost(departamento: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public departamentoPost(departamento: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public departamentoPost(departamento: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (departamento === null || departamento === undefined) {
            throw new Error('Required parameter departamento was null or undefined when calling departamentoPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/departamento`,
            departamento,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los diagnosticos incapacidad
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public diagnosticoincapacidadGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Diagnosticoincapacidad>>;
    public diagnosticoincapacidadGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Diagnosticoincapacidad>>>;
    public diagnosticoincapacidadGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Diagnosticoincapacidad>>>;
    public diagnosticoincapacidadGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Diagnosticoincapacidad>>(`${this.basePath}/diagnosticoincapacidad`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un diagnostico incapacidad por id
     * 
     * @param iddiagnosticoIncapacidad id del diagnostico incapacidad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public diagnosticoincapacidadIddiagnosticoIncapacidadGet(iddiagnosticoIncapacidad: number, observe?: 'body', reportProgress?: boolean): Observable<Diagnosticoincapacidad>;
    public diagnosticoincapacidadIddiagnosticoIncapacidadGet(iddiagnosticoIncapacidad: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Diagnosticoincapacidad>>;
    public diagnosticoincapacidadIddiagnosticoIncapacidadGet(iddiagnosticoIncapacidad: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Diagnosticoincapacidad>>;
    public diagnosticoincapacidadIddiagnosticoIncapacidadGet(iddiagnosticoIncapacidad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (iddiagnosticoIncapacidad === null || iddiagnosticoIncapacidad === undefined) {
            throw new Error('Required parameter iddiagnosticoIncapacidad was null or undefined when calling diagnosticoincapacidadIddiagnosticoIncapacidadGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Diagnosticoincapacidad>(`${this.basePath}/diagnosticoincapacidad/${encodeURIComponent(String(iddiagnosticoIncapacidad))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un diagnostico incapacidad por id
     * 
     * @param iddiagnosticoIncapacidad id del diagnostico incapacidad
     * @param diagnosticoIncapacidad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public diagnosticoincapacidadIddiagnosticoIncapacidadPut(iddiagnosticoIncapacidad: number, diagnosticoIncapacidad?: any, observe?: 'body', reportProgress?: boolean): Observable<Diagnosticoincapacidad>;
    public diagnosticoincapacidadIddiagnosticoIncapacidadPut(iddiagnosticoIncapacidad: number, diagnosticoIncapacidad?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Diagnosticoincapacidad>>;
    public diagnosticoincapacidadIddiagnosticoIncapacidadPut(iddiagnosticoIncapacidad: number, diagnosticoIncapacidad?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Diagnosticoincapacidad>>;
    public diagnosticoincapacidadIddiagnosticoIncapacidadPut(iddiagnosticoIncapacidad: number, diagnosticoIncapacidad?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (iddiagnosticoIncapacidad === null || iddiagnosticoIncapacidad === undefined) {
            throw new Error('Required parameter iddiagnosticoIncapacidad was null or undefined when calling diagnosticoincapacidadIddiagnosticoIncapacidadPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Diagnosticoincapacidad>(`${this.basePath}/diagnosticoincapacidad/${encodeURIComponent(String(iddiagnosticoIncapacidad))}`,
            diagnosticoIncapacidad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de diagnosticoIncapacidad
     * 
     * @param diagnosticoIncapacidad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public diagnosticoincapacidadPost(diagnosticoIncapacidad: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public diagnosticoincapacidadPost(diagnosticoIncapacidad: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public diagnosticoincapacidadPost(diagnosticoIncapacidad: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public diagnosticoincapacidadPost(diagnosticoIncapacidad: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (diagnosticoIncapacidad === null || diagnosticoIncapacidad === undefined) {
            throw new Error('Required parameter diagnosticoIncapacidad was null or undefined when calling diagnosticoincapacidadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/diagnosticoincapacidad`,
            diagnosticoIncapacidad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos las evidencias de cumplimiento
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public evidenciacumplimientoGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Evidenciacumplimiento>>;
    public evidenciacumplimientoGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Evidenciacumplimiento>>>;
    public evidenciacumplimientoGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Evidenciacumplimiento>>>;
    public evidenciacumplimientoGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Evidenciacumplimiento>>(`${this.basePath}/evidenciacumplimiento`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae una evidencia de cumplimiento por id
     * 
     * @param idEvidenciaCumplimiento id de la evidencia cumplimiento
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public evidenciacumplimientoIdEvidenciaCumplimientoGet(idEvidenciaCumplimiento: number, observe?: 'body', reportProgress?: boolean): Observable<Evidenciacumplimiento>;
    public evidenciacumplimientoIdEvidenciaCumplimientoGet(idEvidenciaCumplimiento: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Evidenciacumplimiento>>;
    public evidenciacumplimientoIdEvidenciaCumplimientoGet(idEvidenciaCumplimiento: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Evidenciacumplimiento>>;
    public evidenciacumplimientoIdEvidenciaCumplimientoGet(idEvidenciaCumplimiento: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idEvidenciaCumplimiento === null || idEvidenciaCumplimiento === undefined) {
            throw new Error('Required parameter idEvidenciaCumplimiento was null or undefined when calling evidenciacumplimientoIdEvidenciaCumplimientoGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Evidenciacumplimiento>(`${this.basePath}/evidenciacumplimiento/${encodeURIComponent(String(idEvidenciaCumplimiento))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar una evidencia cumplimiento por id
     * 
     * @param idEvidenciaCumplimiento id de la evidenciacumplimiento
     * @param evidenciaCumplimiento 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public evidenciacumplimientoIdEvidenciaCumplimientoPut(idEvidenciaCumplimiento: number, evidenciaCumplimiento?: any, observe?: 'body', reportProgress?: boolean): Observable<Evidenciacumplimiento>;
    public evidenciacumplimientoIdEvidenciaCumplimientoPut(idEvidenciaCumplimiento: number, evidenciaCumplimiento?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Evidenciacumplimiento>>;
    public evidenciacumplimientoIdEvidenciaCumplimientoPut(idEvidenciaCumplimiento: number, evidenciaCumplimiento?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Evidenciacumplimiento>>;
    public evidenciacumplimientoIdEvidenciaCumplimientoPut(idEvidenciaCumplimiento: number, evidenciaCumplimiento?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idEvidenciaCumplimiento === null || idEvidenciaCumplimiento === undefined) {
            throw new Error('Required parameter idEvidenciaCumplimiento was null or undefined when calling evidenciacumplimientoIdEvidenciaCumplimientoPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Evidenciacumplimiento>(`${this.basePath}/evidenciacumplimiento/${encodeURIComponent(String(idEvidenciaCumplimiento))}`,
            evidenciaCumplimiento,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de evidenciaCumplimiento
     * 
     * @param evidenciaCumplimiento 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public evidenciacumplimientoPost(evidenciaCumplimiento: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public evidenciacumplimientoPost(evidenciaCumplimiento: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public evidenciacumplimientoPost(evidenciaCumplimiento: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public evidenciacumplimientoPost(evidenciaCumplimiento: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (evidenciaCumplimiento === null || evidenciaCumplimiento === undefined) {
            throw new Error('Required parameter evidenciaCumplimiento was null or undefined when calling evidenciacumplimientoPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/evidenciacumplimiento`,
            evidenciaCumplimiento,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos las frecuencias
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public frecuenciaGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Frecuencia>>;
    public frecuenciaGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Frecuencia>>>;
    public frecuenciaGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Frecuencia>>>;
    public frecuenciaGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Frecuencia>>(`${this.basePath}/frecuencia`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae una frecuencia por id
     * 
     * @param idFrecuencia id de la frecuencia
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public frecuenciaIdFrecuenciaGet(idFrecuencia: number, observe?: 'body', reportProgress?: boolean): Observable<Frecuencia>;
    public frecuenciaIdFrecuenciaGet(idFrecuencia: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Frecuencia>>;
    public frecuenciaIdFrecuenciaGet(idFrecuencia: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Frecuencia>>;
    public frecuenciaIdFrecuenciaGet(idFrecuencia: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFrecuencia === null || idFrecuencia === undefined) {
            throw new Error('Required parameter idFrecuencia was null or undefined when calling frecuenciaIdFrecuenciaGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Frecuencia>(`${this.basePath}/frecuencia/${encodeURIComponent(String(idFrecuencia))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar una frecuencia por id
     * 
     * @param idFrecuencia id de la frecuencia
     * @param frecuencia 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public frecuenciaIdFrecuenciaPut(idFrecuencia: number, frecuencia?: any, observe?: 'body', reportProgress?: boolean): Observable<Frecuencia>;
    public frecuenciaIdFrecuenciaPut(idFrecuencia: number, frecuencia?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Frecuencia>>;
    public frecuenciaIdFrecuenciaPut(idFrecuencia: number, frecuencia?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Frecuencia>>;
    public frecuenciaIdFrecuenciaPut(idFrecuencia: number, frecuencia?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFrecuencia === null || idFrecuencia === undefined) {
            throw new Error('Required parameter idFrecuencia was null or undefined when calling frecuenciaIdFrecuenciaPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Frecuencia>(`${this.basePath}/frecuencia/${encodeURIComponent(String(idFrecuencia))}`,
            frecuencia,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de frecuencia
     * 
     * @param frecuencia 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public frecuenciaPost(frecuencia: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public frecuenciaPost(frecuencia: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public frecuenciaPost(frecuencia: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public frecuenciaPost(frecuencia: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (frecuencia === null || frecuencia === undefined) {
            throw new Error('Required parameter frecuencia was null or undefined when calling frecuenciaPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/frecuencia`,
            frecuencia,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos las fuentes informacion
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fuenteinformacionGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Fuenteinformacion>>;
    public fuenteinformacionGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Fuenteinformacion>>>;
    public fuenteinformacionGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Fuenteinformacion>>>;
    public fuenteinformacionGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Fuenteinformacion>>(`${this.basePath}/fuenteinformacion`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae una fuente informacion por id
     * 
     * @param idFuenteInformacion id de la fuente informacion
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fuenteinformacionIdFuenteInformacionGet(idFuenteInformacion: number, observe?: 'body', reportProgress?: boolean): Observable<Fuenteinformacion>;
    public fuenteinformacionIdFuenteInformacionGet(idFuenteInformacion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Fuenteinformacion>>;
    public fuenteinformacionIdFuenteInformacionGet(idFuenteInformacion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Fuenteinformacion>>;
    public fuenteinformacionIdFuenteInformacionGet(idFuenteInformacion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFuenteInformacion === null || idFuenteInformacion === undefined) {
            throw new Error('Required parameter idFuenteInformacion was null or undefined when calling fuenteinformacionIdFuenteInformacionGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Fuenteinformacion>(`${this.basePath}/fuenteinformacion/${encodeURIComponent(String(idFuenteInformacion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar una fuente informacion por id
     * 
     * @param idFuenteInformacion id de la fuente informacion
     * @param fuenteInformacion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fuenteinformacionIdFuenteInformacionPut(idFuenteInformacion: number, fuenteInformacion?: any, observe?: 'body', reportProgress?: boolean): Observable<Fuenteinformacion>;
    public fuenteinformacionIdFuenteInformacionPut(idFuenteInformacion: number, fuenteInformacion?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Fuenteinformacion>>;
    public fuenteinformacionIdFuenteInformacionPut(idFuenteInformacion: number, fuenteInformacion?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Fuenteinformacion>>;
    public fuenteinformacionIdFuenteInformacionPut(idFuenteInformacion: number, fuenteInformacion?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFuenteInformacion === null || idFuenteInformacion === undefined) {
            throw new Error('Required parameter idFuenteInformacion was null or undefined when calling fuenteinformacionIdFuenteInformacionPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Fuenteinformacion>(`${this.basePath}/fuenteinformacion/${encodeURIComponent(String(idFuenteInformacion))}`,
            fuenteInformacion,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de fuenteInformacion
     * 
     * @param fuenteInformacion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fuenteinformacionPost(fuenteInformacion: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public fuenteinformacionPost(fuenteInformacion: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public fuenteinformacionPost(fuenteInformacion: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public fuenteinformacionPost(fuenteInformacion: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fuenteInformacion === null || fuenteInformacion === undefined) {
            throw new Error('Required parameter fuenteInformacion was null or undefined when calling fuenteinformacionPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/fuenteinformacion`,
            fuenteInformacion,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos idoneidad instructor
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public idoneidadInstructorGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Idoneidadinstructor>>;
    public idoneidadInstructorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Idoneidadinstructor>>>;
    public idoneidadInstructorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Idoneidadinstructor>>>;
    public idoneidadInstructorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Idoneidadinstructor>>(`${this.basePath}/idoneidad_instructor`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo actividad por id
     * 
     * @param idIdoneidadInstructor id del idoneidad instructor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public idoneidadInstructorIdIdoneidadInstructorGet(idIdoneidadInstructor: number, observe?: 'body', reportProgress?: boolean): Observable<Idoneidadinstructor>;
    public idoneidadInstructorIdIdoneidadInstructorGet(idIdoneidadInstructor: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Idoneidadinstructor>>;
    public idoneidadInstructorIdIdoneidadInstructorGet(idIdoneidadInstructor: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Idoneidadinstructor>>;
    public idoneidadInstructorIdIdoneidadInstructorGet(idIdoneidadInstructor: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idIdoneidadInstructor === null || idIdoneidadInstructor === undefined) {
            throw new Error('Required parameter idIdoneidadInstructor was null or undefined when calling idoneidadInstructorIdIdoneidadInstructorGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Idoneidadinstructor>(`${this.basePath}/idoneidad_instructor/${encodeURIComponent(String(idIdoneidadInstructor))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo idoneidad instructor por id
     * 
     * @param idIdoneidadInstructor id del tipo idoneidad instructor
     * @param idoneidadInstructor 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public idoneidadInstructorIdIdoneidadInstructorPut(idIdoneidadInstructor: number, idoneidadInstructor?: any, observe?: 'body', reportProgress?: boolean): Observable<Idoneidadinstructor>;
    public idoneidadInstructorIdIdoneidadInstructorPut(idIdoneidadInstructor: number, idoneidadInstructor?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Idoneidadinstructor>>;
    public idoneidadInstructorIdIdoneidadInstructorPut(idIdoneidadInstructor: number, idoneidadInstructor?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Idoneidadinstructor>>;
    public idoneidadInstructorIdIdoneidadInstructorPut(idIdoneidadInstructor: number, idoneidadInstructor?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idIdoneidadInstructor === null || idIdoneidadInstructor === undefined) {
            throw new Error('Required parameter idIdoneidadInstructor was null or undefined when calling idoneidadInstructorIdIdoneidadInstructorPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Idoneidadinstructor>(`${this.basePath}/idoneidad_instructor/${encodeURIComponent(String(idIdoneidadInstructor))}`,
            idoneidadInstructor,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipo idoneidad instructor
     * 
     * @param idoneidadInstructor 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public idoneidadInstructorPost(idoneidadInstructor: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public idoneidadInstructorPost(idoneidadInstructor: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public idoneidadInstructorPost(idoneidadInstructor: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public idoneidadInstructorPost(idoneidadInstructor: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idoneidadInstructor === null || idoneidadInstructor === undefined) {
            throw new Error('Required parameter idoneidadInstructor was null or undefined when calling idoneidadInstructorPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/idoneidad_instructor`,
            idoneidadInstructor,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos las partes cuerpo
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public partecuerpoGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Partecuerpo>>;
    public partecuerpoGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Partecuerpo>>>;
    public partecuerpoGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Partecuerpo>>>;
    public partecuerpoGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Partecuerpo>>(`${this.basePath}/partecuerpo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae una parte cuerpo por id
     * 
     * @param idParteCuerpo id de la parte cuerpo
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public partecuerpoIdParteCuerpoGet(idParteCuerpo: number, observe?: 'body', reportProgress?: boolean): Observable<Partecuerpo>;
    public partecuerpoIdParteCuerpoGet(idParteCuerpo: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Partecuerpo>>;
    public partecuerpoIdParteCuerpoGet(idParteCuerpo: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Partecuerpo>>;
    public partecuerpoIdParteCuerpoGet(idParteCuerpo: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idParteCuerpo === null || idParteCuerpo === undefined) {
            throw new Error('Required parameter idParteCuerpo was null or undefined when calling partecuerpoIdParteCuerpoGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Partecuerpo>(`${this.basePath}/partecuerpo/${encodeURIComponent(String(idParteCuerpo))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar una parte cuerpo por id
     * 
     * @param idParteCuerpo id de la parte cuerpo
     * @param parteCuerpo 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public partecuerpoIdParteCuerpoPut(idParteCuerpo: number, parteCuerpo?: any, observe?: 'body', reportProgress?: boolean): Observable<Partecuerpo>;
    public partecuerpoIdParteCuerpoPut(idParteCuerpo: number, parteCuerpo?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Partecuerpo>>;
    public partecuerpoIdParteCuerpoPut(idParteCuerpo: number, parteCuerpo?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Partecuerpo>>;
    public partecuerpoIdParteCuerpoPut(idParteCuerpo: number, parteCuerpo?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idParteCuerpo === null || idParteCuerpo === undefined) {
            throw new Error('Required parameter idParteCuerpo was null or undefined when calling partecuerpoIdParteCuerpoPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Partecuerpo>(`${this.basePath}/partecuerpo/${encodeURIComponent(String(idParteCuerpo))}`,
            parteCuerpo,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de parte cuerpo
     * 
     * @param parteCuerpo 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public partecuerpoPost(parteCuerpo: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public partecuerpoPost(parteCuerpo: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public partecuerpoPost(parteCuerpo: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public partecuerpoPost(parteCuerpo: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (parteCuerpo === null || parteCuerpo === undefined) {
            throw new Error('Required parameter parteCuerpo was null or undefined when calling partecuerpoPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/partecuerpo`,
            parteCuerpo,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae una pregunta de la encuesta
     * 
     * @param idPregunta id de la pregunta
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public preguntaencuestaIdPreguntaGet(idPregunta: number, observe?: 'body', reportProgress?: boolean): Observable<Preguntasencuesta>;
    public preguntaencuestaIdPreguntaGet(idPregunta: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Preguntasencuesta>>;
    public preguntaencuestaIdPreguntaGet(idPregunta: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Preguntasencuesta>>;
    public preguntaencuestaIdPreguntaGet(idPregunta: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idPregunta === null || idPregunta === undefined) {
            throw new Error('Required parameter idPregunta was null or undefined when calling preguntaencuestaIdPreguntaGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Preguntasencuesta>(`${this.basePath}/preguntaencuesta/${encodeURIComponent(String(idPregunta))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar una pregunta por id
     * 
     * @param idPregunta id de la pregunta
     * @param preguntaEncuesta 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public preguntaencuestaIdPreguntaPut(idPregunta: number, preguntaEncuesta?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipoevento>;
    public preguntaencuestaIdPreguntaPut(idPregunta: number, preguntaEncuesta?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoevento>>;
    public preguntaencuestaIdPreguntaPut(idPregunta: number, preguntaEncuesta?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoevento>>;
    public preguntaencuestaIdPreguntaPut(idPregunta: number, preguntaEncuesta?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idPregunta === null || idPregunta === undefined) {
            throw new Error('Required parameter idPregunta was null or undefined when calling preguntaencuestaIdPreguntaPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipoevento>(`${this.basePath}/preguntaencuesta/${encodeURIComponent(String(idPregunta))}`,
            preguntaEncuesta,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos las preguntas
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public preguntasencuestaGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Preguntasencuesta>>;
    public preguntasencuestaGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Preguntasencuesta>>>;
    public preguntasencuestaGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Preguntasencuesta>>>;
    public preguntasencuestaGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Preguntasencuesta>>(`${this.basePath}/preguntasencuesta`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de preguntaEncuesta
     * 
     * @param preguntaEncuesta 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public preguntasencuestaPost(preguntaEncuesta: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public preguntasencuestaPost(preguntaEncuesta: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public preguntasencuestaPost(preguntaEncuesta: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public preguntasencuestaPost(preguntaEncuesta: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (preguntaEncuesta === null || preguntaEncuesta === undefined) {
            throw new Error('Required parameter preguntaEncuesta was null or undefined when calling preguntasencuestaPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/preguntasencuesta`,
            preguntaEncuesta,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los sistemas de evaluacin
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sistemaevaluacionGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Sistemaevaluacion>>;
    public sistemaevaluacionGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Sistemaevaluacion>>>;
    public sistemaevaluacionGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Sistemaevaluacion>>>;
    public sistemaevaluacionGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Sistemaevaluacion>>(`${this.basePath}/sistemaevaluacion`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un sistema de evaluacin por id
     * 
     * @param idSistemaEvaluacion id de la sistema de evaluacin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sistemaevaluacionIdSistemaEvaluacionGet(idSistemaEvaluacion: number, observe?: 'body', reportProgress?: boolean): Observable<Sistemaevaluacion>;
    public sistemaevaluacionIdSistemaEvaluacionGet(idSistemaEvaluacion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Sistemaevaluacion>>;
    public sistemaevaluacionIdSistemaEvaluacionGet(idSistemaEvaluacion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Sistemaevaluacion>>;
    public sistemaevaluacionIdSistemaEvaluacionGet(idSistemaEvaluacion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSistemaEvaluacion === null || idSistemaEvaluacion === undefined) {
            throw new Error('Required parameter idSistemaEvaluacion was null or undefined when calling sistemaevaluacionIdSistemaEvaluacionGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Sistemaevaluacion>(`${this.basePath}/sistemaevaluacion/${encodeURIComponent(String(idSistemaEvaluacion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un sistema de evaluacin por id
     * 
     * @param idSistemaEvaluacion id del sistema de evaluacin
     * @param sistemaEvaluacion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sistemaevaluacionIdSistemaEvaluacionPut(idSistemaEvaluacion: number, sistemaEvaluacion?: any, observe?: 'body', reportProgress?: boolean): Observable<Sistemaevaluacion>;
    public sistemaevaluacionIdSistemaEvaluacionPut(idSistemaEvaluacion: number, sistemaEvaluacion?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Sistemaevaluacion>>;
    public sistemaevaluacionIdSistemaEvaluacionPut(idSistemaEvaluacion: number, sistemaEvaluacion?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Sistemaevaluacion>>;
    public sistemaevaluacionIdSistemaEvaluacionPut(idSistemaEvaluacion: number, sistemaEvaluacion?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSistemaEvaluacion === null || idSistemaEvaluacion === undefined) {
            throw new Error('Required parameter idSistemaEvaluacion was null or undefined when calling sistemaevaluacionIdSistemaEvaluacionPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Sistemaevaluacion>(`${this.basePath}/sistemaevaluacion/${encodeURIComponent(String(idSistemaEvaluacion))}`,
            sistemaEvaluacion,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de sistemaEvaluacion
     * 
     * @param sistemaEvaluacion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sistemaevaluacionPost(sistemaEvaluacion: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public sistemaevaluacionPost(sistemaEvaluacion: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public sistemaevaluacionPost(sistemaEvaluacion: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public sistemaevaluacionPost(sistemaEvaluacion: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (sistemaEvaluacion === null || sistemaEvaluacion === undefined) {
            throw new Error('Required parameter sistemaEvaluacion was null or undefined when calling sistemaevaluacionPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/sistemaevaluacion`,
            sistemaEvaluacion,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos de accidente
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoaccidenteGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tipoaccidente>>;
    public tipoaccidenteGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tipoaccidente>>>;
    public tipoaccidenteGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tipoaccidente>>>;
    public tipoaccidenteGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tipoaccidente>>(`${this.basePath}/tipoaccidente`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo de accidente por id
     * 
     * @param idTipoAccidente id tipo de accidente
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoaccidenteIdTipoAccidenteGet(idTipoAccidente: number, observe?: 'body', reportProgress?: boolean): Observable<Tipoaccidente>;
    public tipoaccidenteIdTipoAccidenteGet(idTipoAccidente: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoaccidente>>;
    public tipoaccidenteIdTipoAccidenteGet(idTipoAccidente: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoaccidente>>;
    public tipoaccidenteIdTipoAccidenteGet(idTipoAccidente: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoAccidente === null || idTipoAccidente === undefined) {
            throw new Error('Required parameter idTipoAccidente was null or undefined when calling tipoaccidenteIdTipoAccidenteGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tipoaccidente>(`${this.basePath}/tipoaccidente/${encodeURIComponent(String(idTipoAccidente))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo de accidente por id
     * 
     * @param idTipoAccidente id tipo de accidente
     * @param tipoAccidente 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoaccidenteIdTipoAccidentePut(idTipoAccidente: number, tipoAccidente?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipoaccidente>;
    public tipoaccidenteIdTipoAccidentePut(idTipoAccidente: number, tipoAccidente?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoaccidente>>;
    public tipoaccidenteIdTipoAccidentePut(idTipoAccidente: number, tipoAccidente?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoaccidente>>;
    public tipoaccidenteIdTipoAccidentePut(idTipoAccidente: number, tipoAccidente?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoAccidente === null || idTipoAccidente === undefined) {
            throw new Error('Required parameter idTipoAccidente was null or undefined when calling tipoaccidenteIdTipoAccidentePut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipoaccidente>(`${this.basePath}/tipoaccidente/${encodeURIComponent(String(idTipoAccidente))}`,
            tipoAccidente,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipoaccidente
     * 
     * @param tipoaccidente 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoaccidentePost(tipoaccidente: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tipoaccidentePost(tipoaccidente: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tipoaccidentePost(tipoaccidente: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tipoaccidentePost(tipoaccidente: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoaccidente === null || tipoaccidente === undefined) {
            throw new Error('Required parameter tipoaccidente was null or undefined when calling tipoaccidentePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tipoaccidente`,
            tipoaccidente,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos actividad
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoactividadGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tipoactividad>>;
    public tipoactividadGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tipoactividad>>>;
    public tipoactividadGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tipoactividad>>>;
    public tipoactividadGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tipoactividad>>(`${this.basePath}/tipoactividad`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo actividad por id
     * 
     * @param idTipoActividad id del tipo actividad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoactividadIdTipoActividadGet(idTipoActividad: number, observe?: 'body', reportProgress?: boolean): Observable<Tipoactividad>;
    public tipoactividadIdTipoActividadGet(idTipoActividad: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoactividad>>;
    public tipoactividadIdTipoActividadGet(idTipoActividad: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoactividad>>;
    public tipoactividadIdTipoActividadGet(idTipoActividad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoActividad === null || idTipoActividad === undefined) {
            throw new Error('Required parameter idTipoActividad was null or undefined when calling tipoactividadIdTipoActividadGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tipoactividad>(`${this.basePath}/tipoactividad/${encodeURIComponent(String(idTipoActividad))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo actividad por id
     * 
     * @param idTipoActividad id del tipo actividad
     * @param tipoActividad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoactividadIdTipoActividadPut(idTipoActividad: number, tipoActividad?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipoactividad>;
    public tipoactividadIdTipoActividadPut(idTipoActividad: number, tipoActividad?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoactividad>>;
    public tipoactividadIdTipoActividadPut(idTipoActividad: number, tipoActividad?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoactividad>>;
    public tipoactividadIdTipoActividadPut(idTipoActividad: number, tipoActividad?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoActividad === null || idTipoActividad === undefined) {
            throw new Error('Required parameter idTipoActividad was null or undefined when calling tipoactividadIdTipoActividadPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipoactividad>(`${this.basePath}/tipoactividad/${encodeURIComponent(String(idTipoActividad))}`,
            tipoActividad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipo actividad
     * 
     * @param tipoActividad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoactividadPost(tipoActividad: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tipoactividadPost(tipoActividad: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tipoactividadPost(tipoActividad: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tipoactividadPost(tipoActividad: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoActividad === null || tipoActividad === undefined) {
            throw new Error('Required parameter tipoActividad was null or undefined when calling tipoactividadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tipoactividad`,
            tipoActividad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos de contrato
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipocontratoGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tipocontrato>>;
    public tipocontratoGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tipocontrato>>>;
    public tipocontratoGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tipocontrato>>>;
    public tipocontratoGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tipocontrato>>(`${this.basePath}/tipocontrato`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo de contrato por id
     * 
     * @param idTipoContrato id tipo de contrato
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipocontratoIdTipoContratoGet(idTipoContrato: number, observe?: 'body', reportProgress?: boolean): Observable<Tipocontrato>;
    public tipocontratoIdTipoContratoGet(idTipoContrato: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipocontrato>>;
    public tipocontratoIdTipoContratoGet(idTipoContrato: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipocontrato>>;
    public tipocontratoIdTipoContratoGet(idTipoContrato: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoContrato === null || idTipoContrato === undefined) {
            throw new Error('Required parameter idTipoContrato was null or undefined when calling tipocontratoIdTipoContratoGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tipocontrato>(`${this.basePath}/tipocontrato/${encodeURIComponent(String(idTipoContrato))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo de contrato por id
     * 
     * @param idTipoContrato id tipo de contrato
     * @param tipoContrato 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipocontratoIdTipoContratoPut(idTipoContrato: number, tipoContrato?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipocontrato>;
    public tipocontratoIdTipoContratoPut(idTipoContrato: number, tipoContrato?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipocontrato>>;
    public tipocontratoIdTipoContratoPut(idTipoContrato: number, tipoContrato?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipocontrato>>;
    public tipocontratoIdTipoContratoPut(idTipoContrato: number, tipoContrato?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoContrato === null || idTipoContrato === undefined) {
            throw new Error('Required parameter idTipoContrato was null or undefined when calling tipocontratoIdTipoContratoPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipocontrato>(`${this.basePath}/tipocontrato/${encodeURIComponent(String(idTipoContrato))}`,
            tipoContrato,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipoContrato
     * 
     * @param tipoContrato 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipocontratoPost(tipoContrato: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tipocontratoPost(tipoContrato: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tipocontratoPost(tipoContrato: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tipocontratoPost(tipoContrato: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoContrato === null || tipoContrato === undefined) {
            throw new Error('Required parameter tipoContrato was null or undefined when calling tipocontratoPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tipocontrato`,
            tipoContrato,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos de evento
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoeventoGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tipoevento>>;
    public tipoeventoGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tipoevento>>>;
    public tipoeventoGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tipoevento>>>;
    public tipoeventoGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tipoevento>>(`${this.basePath}/tipoevento`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo de evento por id
     * 
     * @param idTipoEvento id tipo de evento
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoeventoIdTipoEventoGet(idTipoEvento: number, observe?: 'body', reportProgress?: boolean): Observable<Tipoevento>;
    public tipoeventoIdTipoEventoGet(idTipoEvento: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoevento>>;
    public tipoeventoIdTipoEventoGet(idTipoEvento: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoevento>>;
    public tipoeventoIdTipoEventoGet(idTipoEvento: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoEvento === null || idTipoEvento === undefined) {
            throw new Error('Required parameter idTipoEvento was null or undefined when calling tipoeventoIdTipoEventoGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tipoevento>(`${this.basePath}/tipoevento/${encodeURIComponent(String(idTipoEvento))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo de evento por id
     * 
     * @param idTipoEvento id tipo de evento
     * @param tipoEvento 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoeventoIdTipoEventoPut(idTipoEvento: number, tipoEvento?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipoevento>;
    public tipoeventoIdTipoEventoPut(idTipoEvento: number, tipoEvento?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoevento>>;
    public tipoeventoIdTipoEventoPut(idTipoEvento: number, tipoEvento?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoevento>>;
    public tipoeventoIdTipoEventoPut(idTipoEvento: number, tipoEvento?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoEvento === null || idTipoEvento === undefined) {
            throw new Error('Required parameter idTipoEvento was null or undefined when calling tipoeventoIdTipoEventoPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipoevento>(`${this.basePath}/tipoevento/${encodeURIComponent(String(idTipoEvento))}`,
            tipoEvento,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipoEvento
     * 
     * @param tipoEvento 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoeventoPost(tipoEvento: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tipoeventoPost(tipoEvento: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tipoeventoPost(tipoEvento: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tipoeventoPost(tipoEvento: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoEvento === null || tipoEvento === undefined) {
            throw new Error('Required parameter tipoEvento was null or undefined when calling tipoeventoPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tipoevento`,
            tipoEvento,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos indicador
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoindicadorGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tipoindicador>>;
    public tipoindicadorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tipoindicador>>>;
    public tipoindicadorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tipoindicador>>>;
    public tipoindicadorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tipoindicador>>(`${this.basePath}/tipoindicador`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo indicador por id
     * 
     * @param idTipoIndicador id del tipo indicador
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoindicadorIdTipoIndicadorGet(idTipoIndicador: number, observe?: 'body', reportProgress?: boolean): Observable<Tipoindicador>;
    public tipoindicadorIdTipoIndicadorGet(idTipoIndicador: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoindicador>>;
    public tipoindicadorIdTipoIndicadorGet(idTipoIndicador: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoindicador>>;
    public tipoindicadorIdTipoIndicadorGet(idTipoIndicador: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoIndicador === null || idTipoIndicador === undefined) {
            throw new Error('Required parameter idTipoIndicador was null or undefined when calling tipoindicadorIdTipoIndicadorGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tipoindicador>(`${this.basePath}/tipoindicador/${encodeURIComponent(String(idTipoIndicador))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo indicador por id
     * 
     * @param idTipoIndicador id del tipo indicador
     * @param tipoIndicador 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoindicadorIdTipoIndicadorPut(idTipoIndicador: number, tipoIndicador?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipoindicador>;
    public tipoindicadorIdTipoIndicadorPut(idTipoIndicador: number, tipoIndicador?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipoindicador>>;
    public tipoindicadorIdTipoIndicadorPut(idTipoIndicador: number, tipoIndicador?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipoindicador>>;
    public tipoindicadorIdTipoIndicadorPut(idTipoIndicador: number, tipoIndicador?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoIndicador === null || idTipoIndicador === undefined) {
            throw new Error('Required parameter idTipoIndicador was null or undefined when calling tipoindicadorIdTipoIndicadorPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipoindicador>(`${this.basePath}/tipoindicador/${encodeURIComponent(String(idTipoIndicador))}`,
            tipoIndicador,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipo indicador
     * 
     * @param tipoIndicador 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipoindicadorPost(tipoIndicador: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tipoindicadorPost(tipoIndicador: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tipoindicadorPost(tipoIndicador: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tipoindicadorPost(tipoIndicador: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoIndicador === null || tipoIndicador === undefined) {
            throw new Error('Required parameter tipoIndicador was null or undefined when calling tipoindicadorPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tipoindicador`,
            tipoIndicador,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipos lesion
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipolesionGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tipolesion>>;
    public tipolesionGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tipolesion>>>;
    public tipolesionGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tipolesion>>>;
    public tipolesionGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tipolesion>>(`${this.basePath}/tipolesion`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo lesion por id
     * 
     * @param idTipoLesion id del tipo lesion
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipolesionIdTipoLesionGet(idTipoLesion: number, observe?: 'body', reportProgress?: boolean): Observable<Tipolesion>;
    public tipolesionIdTipoLesionGet(idTipoLesion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipolesion>>;
    public tipolesionIdTipoLesionGet(idTipoLesion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipolesion>>;
    public tipolesionIdTipoLesionGet(idTipoLesion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoLesion === null || idTipoLesion === undefined) {
            throw new Error('Required parameter idTipoLesion was null or undefined when calling tipolesionIdTipoLesionGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tipolesion>(`${this.basePath}/tipolesion/${encodeURIComponent(String(idTipoLesion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo lesion por id
     * 
     * @param idTipoLesion id del tipo lesion
     * @param tipoLesion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipolesionIdTipoLesionPut(idTipoLesion: number, tipoLesion?: any, observe?: 'body', reportProgress?: boolean): Observable<Tipolesion>;
    public tipolesionIdTipoLesionPut(idTipoLesion: number, tipoLesion?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tipolesion>>;
    public tipolesionIdTipoLesionPut(idTipoLesion: number, tipoLesion?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tipolesion>>;
    public tipolesionIdTipoLesionPut(idTipoLesion: number, tipoLesion?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoLesion === null || idTipoLesion === undefined) {
            throw new Error('Required parameter idTipoLesion was null or undefined when calling tipolesionIdTipoLesionPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tipolesion>(`${this.basePath}/tipolesion/${encodeURIComponent(String(idTipoLesion))}`,
            tipoLesion,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipo lesion
     * 
     * @param tipolesion 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tipolesionPost(tipolesion: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tipolesionPost(tipolesion: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tipolesionPost(tipolesion: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tipolesionPost(tipolesion: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipolesion === null || tipolesion === undefined) {
            throw new Error('Required parameter tipolesion was null or undefined when calling tipolesionPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tipolesion`,
            tipolesion,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipo recurso
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporecursoGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tiporecurso>>;
    public tiporecursoGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tiporecurso>>>;
    public tiporecursoGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tiporecurso>>>;
    public tiporecursoGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tiporecurso>>(`${this.basePath}/tiporecurso`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo recurso por id
     * 
     * @param idTipoRecurso id del tipo recurso
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporecursoIdTipoRecursoGet(idTipoRecurso: number, observe?: 'body', reportProgress?: boolean): Observable<Tiporecurso>;
    public tiporecursoIdTipoRecursoGet(idTipoRecurso: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tiporecurso>>;
    public tiporecursoIdTipoRecursoGet(idTipoRecurso: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tiporecurso>>;
    public tiporecursoIdTipoRecursoGet(idTipoRecurso: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoRecurso === null || idTipoRecurso === undefined) {
            throw new Error('Required parameter idTipoRecurso was null or undefined when calling tiporecursoIdTipoRecursoGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tiporecurso>(`${this.basePath}/tiporecurso/${encodeURIComponent(String(idTipoRecurso))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo recurso por id
     * 
     * @param idTipoRecurso id del tipo recurso
     * @param tipoRecurso 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporecursoIdTipoRecursoPut(idTipoRecurso: number, tipoRecurso?: any, observe?: 'body', reportProgress?: boolean): Observable<Tiporecurso>;
    public tiporecursoIdTipoRecursoPut(idTipoRecurso: number, tipoRecurso?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tiporecurso>>;
    public tiporecursoIdTipoRecursoPut(idTipoRecurso: number, tipoRecurso?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tiporecurso>>;
    public tiporecursoIdTipoRecursoPut(idTipoRecurso: number, tipoRecurso?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoRecurso === null || idTipoRecurso === undefined) {
            throw new Error('Required parameter idTipoRecurso was null or undefined when calling tiporecursoIdTipoRecursoPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tiporecurso>(`${this.basePath}/tiporecurso/${encodeURIComponent(String(idTipoRecurso))}`,
            tipoRecurso,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipo recurso
     * 
     * @param tipoRecurso 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporecursoPost(tipoRecurso: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tiporecursoPost(tipoRecurso: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tiporecursoPost(tipoRecurso: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tiporecursoPost(tipoRecurso: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoRecurso === null || tipoRecurso === undefined) {
            throw new Error('Required parameter tipoRecurso was null or undefined when calling tiporecursoPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tiporecurso`,
            tipoRecurso,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae todos los tipo responsabilidad
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporesponsabilidadGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Tiporesponsabilidad>>;
    public tiporesponsabilidadGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tiporesponsabilidad>>>;
    public tiporesponsabilidadGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tiporesponsabilidad>>>;
    public tiporesponsabilidadGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Tiporesponsabilidad>>(`${this.basePath}/tiporesponsabilidad`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trae un tipo recurso por id
     * 
     * @param idTipoResponsabilidad id del tipo responsabilidad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporesponsabilidadIdTipoResponsabilidadGet(idTipoResponsabilidad: number, observe?: 'body', reportProgress?: boolean): Observable<Tiporesponsabilidad>;
    public tiporesponsabilidadIdTipoResponsabilidadGet(idTipoResponsabilidad: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tiporesponsabilidad>>;
    public tiporesponsabilidadIdTipoResponsabilidadGet(idTipoResponsabilidad: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tiporesponsabilidad>>;
    public tiporesponsabilidadIdTipoResponsabilidadGet(idTipoResponsabilidad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoResponsabilidad === null || idTipoResponsabilidad === undefined) {
            throw new Error('Required parameter idTipoResponsabilidad was null or undefined when calling tiporesponsabilidadIdTipoResponsabilidadGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Tiporesponsabilidad>(`${this.basePath}/tiporesponsabilidad/${encodeURIComponent(String(idTipoResponsabilidad))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Editar un tipo responsabilidad por id
     * 
     * @param idTipoResponsabilidad id del tipo responsabilidad
     * @param tipoResponsabilidad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporesponsabilidadIdTipoResponsabilidadPut(idTipoResponsabilidad: number, tipoResponsabilidad?: any, observe?: 'body', reportProgress?: boolean): Observable<Tiporesponsabilidad>;
    public tiporesponsabilidadIdTipoResponsabilidadPut(idTipoResponsabilidad: number, tipoResponsabilidad?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tiporesponsabilidad>>;
    public tiporesponsabilidadIdTipoResponsabilidadPut(idTipoResponsabilidad: number, tipoResponsabilidad?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tiporesponsabilidad>>;
    public tiporesponsabilidadIdTipoResponsabilidadPut(idTipoResponsabilidad: number, tipoResponsabilidad?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTipoResponsabilidad === null || idTipoResponsabilidad === undefined) {
            throw new Error('Required parameter idTipoResponsabilidad was null or undefined when calling tiporesponsabilidadIdTipoResponsabilidadPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tiporesponsabilidad>(`${this.basePath}/tiporesponsabilidad/${encodeURIComponent(String(idTipoResponsabilidad))}`,
            tipoResponsabilidad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de tipo responsabilidad
     * 
     * @param tipoResponsabilidad 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tiporesponsabilidadPost(tipoResponsabilidad: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public tiporesponsabilidadPost(tipoResponsabilidad: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public tiporesponsabilidadPost(tipoResponsabilidad: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public tiporesponsabilidadPost(tipoResponsabilidad: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tipoResponsabilidad === null || tipoResponsabilidad === undefined) {
            throw new Error('Required parameter tipoResponsabilidad was null or undefined when calling tiporesponsabilidadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tiporesponsabilidad`,
            tipoResponsabilidad,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
